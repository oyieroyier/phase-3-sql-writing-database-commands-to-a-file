{"version":3,"file":"Tokenizer.js","names":["Tokenizer","cfg","rulesBeforeParams","buildRulesBeforeParams","rulesAfterParams","buildRulesAfterParams","input","paramTypesOverrides","rules","buildParamRules","tokens","TokenizerEngine","tokenize","postProcess","validRules","type","TokenType","BLOCK_COMMENT","regex","nestedBlockComments","NestedComment","LINE_COMMENT","lineComment","lineCommentTypes","QUOTED_IDENTIFIER","string","identTypes","NUMBER","RESERVED_PHRASE","reservedWord","reservedPhrases","identChars","text","toCanonical","CASE","END","BETWEEN","LIMIT","reservedCommands","includes","undefined","RESERVED_COMMAND","RESERVED_SELECT","reservedSelect","RESERVED_SET_OPERATION","reservedSetOperations","RESERVED_DEPENDENT_CLAUSE","reservedDependentClauses","RESERVED_JOIN","reservedJoins","AND","OR","XOR","supportsXor","RESERVED_FUNCTION_NAME","reservedFunctionNames","RESERVED_KEYWORD","reservedKeywords","VARIABLE","variableTypes","variable","STRING","stringTypes","IDENTIFIER","identifier","DELIMITER","COMMA","OPEN_PAREN","parenthesis","extraParens","CLOSE_PAREN","OPERATOR","operator","operators","ASTERISK","DOT","paramTypes","named","quoted","numbered","positional","NAMED_PARAMETER","parameter","identifierPattern","paramChars","key","v","slice","QUOTED_PARAMETER","stringPattern","tokenKey","quoteChar","replace","RegExp","escapeRegExp","NUMBERED_PARAMETER","POSITIONAL_PARAMETER","filter","rule","Boolean","equalizeWhitespace","toUpperCase"],"sources":["../../src/lexer/Tokenizer.ts"],"sourcesContent":["import { Token, TokenType } from 'src/lexer/token';\nimport * as regex from 'src/lexer/regexFactory';\nimport { ParamTypes, TokenizerOptions } from 'src/lexer/TokenizerOptions';\nimport TokenizerEngine, { TokenRule } from 'src/lexer/TokenizerEngine';\nimport { escapeRegExp } from 'src/lexer/regexUtil';\nimport { equalizeWhitespace, Optional } from 'src/utils';\nimport { NestedComment } from './NestedComment';\n\ntype OptionalTokenRule = Optional<TokenRule, 'regex'>;\n\nexport default class Tokenizer {\n  private rulesBeforeParams: TokenRule[];\n  private rulesAfterParams: TokenRule[];\n\n  constructor(private cfg: TokenizerOptions) {\n    this.rulesBeforeParams = this.buildRulesBeforeParams(cfg);\n    this.rulesAfterParams = this.buildRulesAfterParams(cfg);\n  }\n\n  public tokenize(input: string, paramTypesOverrides: ParamTypes): Token[] {\n    const rules = [\n      ...this.rulesBeforeParams,\n      ...this.buildParamRules(this.cfg, paramTypesOverrides),\n      ...this.rulesAfterParams,\n    ];\n    const tokens = new TokenizerEngine(rules).tokenize(input);\n    return this.cfg.postProcess ? this.cfg.postProcess(tokens) : tokens;\n  }\n\n  // These rules can be cached as they only depend on\n  // the Tokenizer config options specified for each SQL dialect\n  private buildRulesBeforeParams(cfg: TokenizerOptions): TokenRule[] {\n    return this.validRules([\n      {\n        type: TokenType.BLOCK_COMMENT,\n        regex: cfg.nestedBlockComments ? new NestedComment() : /(\\/\\*[^]*?\\*\\/)/uy,\n      },\n      {\n        type: TokenType.LINE_COMMENT,\n        regex: regex.lineComment(cfg.lineCommentTypes ?? ['--']),\n      },\n      {\n        type: TokenType.QUOTED_IDENTIFIER,\n        regex: regex.string(cfg.identTypes),\n      },\n      {\n        type: TokenType.NUMBER,\n        regex:\n          /(?:0x[0-9a-fA-F]+|0b[01]+|(?:-\\s*)?[0-9]+(?:\\.[0-9]*)?(?:[eE][-+]?[0-9]+(?:\\.[0-9]+)?)?)(?!\\w)/uy,\n      },\n      // RESERVED_PHRASE is matched before all other keyword tokens\n      // to e.g. prioritize matching \"TIMESTAMP WITH TIME ZONE\" phrase over \"WITH\" command.\n      {\n        type: TokenType.RESERVED_PHRASE,\n        regex: regex.reservedWord(cfg.reservedPhrases ?? [], cfg.identChars),\n        text: toCanonical,\n      },\n      {\n        type: TokenType.CASE,\n        regex: /CASE\\b/iuy,\n        text: toCanonical,\n      },\n      {\n        type: TokenType.END,\n        regex: /END\\b/iuy,\n        text: toCanonical,\n      },\n      {\n        type: TokenType.BETWEEN,\n        regex: /BETWEEN\\b/iuy,\n        text: toCanonical,\n      },\n      {\n        type: TokenType.LIMIT,\n        regex: cfg.reservedCommands.includes('LIMIT') ? /LIMIT\\b/iuy : undefined,\n        text: toCanonical,\n      },\n      {\n        type: TokenType.RESERVED_COMMAND,\n        regex: regex.reservedWord(cfg.reservedCommands, cfg.identChars),\n        text: toCanonical,\n      },\n      {\n        type: TokenType.RESERVED_SELECT,\n        regex: regex.reservedWord(cfg.reservedSelect, cfg.identChars),\n        text: toCanonical,\n      },\n      {\n        type: TokenType.RESERVED_SET_OPERATION,\n        regex: regex.reservedWord(cfg.reservedSetOperations, cfg.identChars),\n        text: toCanonical,\n      },\n      {\n        type: TokenType.RESERVED_DEPENDENT_CLAUSE,\n        regex: regex.reservedWord(cfg.reservedDependentClauses, cfg.identChars),\n        text: toCanonical,\n      },\n      {\n        type: TokenType.RESERVED_JOIN,\n        regex: regex.reservedWord(cfg.reservedJoins, cfg.identChars),\n        text: toCanonical,\n      },\n      {\n        type: TokenType.AND,\n        regex: /AND\\b/iuy,\n        text: toCanonical,\n      },\n      {\n        type: TokenType.OR,\n        regex: /OR\\b/iuy,\n        text: toCanonical,\n      },\n      {\n        type: TokenType.XOR,\n        regex: cfg.supportsXor ? /XOR\\b/iuy : undefined,\n        text: toCanonical,\n      },\n      {\n        type: TokenType.RESERVED_FUNCTION_NAME,\n        regex: regex.reservedWord(cfg.reservedFunctionNames, cfg.identChars),\n        text: toCanonical,\n      },\n      {\n        type: TokenType.RESERVED_KEYWORD,\n        regex: regex.reservedWord(cfg.reservedKeywords, cfg.identChars),\n        text: toCanonical,\n      },\n    ]);\n  }\n\n  // These rules can also be cached as they only depend on\n  // the Tokenizer config options specified for each SQL dialect\n  private buildRulesAfterParams(cfg: TokenizerOptions): TokenRule[] {\n    return this.validRules([\n      {\n        type: TokenType.VARIABLE,\n        regex: cfg.variableTypes ? regex.variable(cfg.variableTypes) : undefined,\n      },\n      { type: TokenType.STRING, regex: regex.string(cfg.stringTypes) },\n      {\n        type: TokenType.IDENTIFIER,\n        regex: regex.identifier(cfg.identChars),\n      },\n      { type: TokenType.DELIMITER, regex: /[;]/uy },\n      { type: TokenType.COMMA, regex: /[,]/y },\n      {\n        type: TokenType.OPEN_PAREN,\n        regex: regex.parenthesis('open', cfg.extraParens),\n      },\n      {\n        type: TokenType.CLOSE_PAREN,\n        regex: regex.parenthesis('close', cfg.extraParens),\n      },\n      {\n        type: TokenType.OPERATOR,\n        regex: regex.operator([\n          // standard operators\n          '+',\n          '-',\n          '/',\n          '>',\n          '<',\n          '=',\n          '<>',\n          '<=',\n          '>=',\n          '!=',\n          ...(cfg.operators ?? []),\n        ]),\n      },\n      { type: TokenType.ASTERISK, regex: /[*]/uy },\n      { type: TokenType.DOT, regex: /[.]/uy },\n    ]);\n  }\n\n  // These rules can't be blindly cached as the paramTypesOverrides object\n  // can differ on each invocation of the format() function.\n  private buildParamRules(cfg: TokenizerOptions, paramTypesOverrides: ParamTypes): TokenRule[] {\n    // Each dialect has its own default parameter types (if any),\n    // but these can be overriden by the user of the library.\n    const paramTypes = {\n      named: paramTypesOverrides?.named || cfg.paramTypes?.named || [],\n      quoted: paramTypesOverrides?.quoted || cfg.paramTypes?.quoted || [],\n      numbered: paramTypesOverrides?.numbered || cfg.paramTypes?.numbered || [],\n      positional:\n        typeof paramTypesOverrides?.positional === 'boolean'\n          ? paramTypesOverrides.positional\n          : cfg.paramTypes?.positional,\n    };\n\n    return this.validRules([\n      {\n        type: TokenType.NAMED_PARAMETER,\n        regex: regex.parameter(\n          paramTypes.named,\n          regex.identifierPattern(cfg.paramChars || cfg.identChars)\n        ),\n        key: v => v.slice(1),\n      },\n      {\n        type: TokenType.QUOTED_PARAMETER,\n        regex: regex.parameter(paramTypes.quoted, regex.stringPattern(cfg.identTypes)),\n        key: v =>\n          (({ tokenKey, quoteChar }) =>\n            tokenKey.replace(new RegExp(escapeRegExp('\\\\' + quoteChar), 'gu'), quoteChar))({\n            tokenKey: v.slice(2, -1),\n            quoteChar: v.slice(-1),\n          }),\n      },\n      {\n        type: TokenType.NUMBERED_PARAMETER,\n        regex: regex.parameter(paramTypes.numbered, '[0-9]+'),\n        key: v => v.slice(1),\n      },\n      {\n        type: TokenType.POSITIONAL_PARAMETER,\n        regex: paramTypes.positional ? /[?]/y : undefined,\n      },\n    ]);\n  }\n\n  // filters out rules for token types whose regex is undefined\n  private validRules(rules: OptionalTokenRule[]): TokenRule[] {\n    return rules.filter((rule): rule is TokenRule => Boolean(rule.regex));\n  }\n}\n\n/**\n * Converts keywords (and keyword sequences) to canonical form:\n * - in uppercase\n * - single spaces between words\n */\nconst toCanonical = (v: string) => equalizeWhitespace(v.toUpperCase());\n"],"mappings":"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"}