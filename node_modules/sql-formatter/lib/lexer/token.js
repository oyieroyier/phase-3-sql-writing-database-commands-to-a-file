"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.testToken = exports.isToken = exports.isReserved = exports.isLogicalOperator = exports.createEofToken = exports.TokenType = exports.EOF_TOKEN = void 0;

/** Token type enum for all possible Token categories */
var TokenType;
/** Struct to store the most basic cohesive unit of language grammar */

exports.TokenType = TokenType;

(function (TokenType) {
  TokenType["QUOTED_IDENTIFIER"] = "QUOTED_IDENTIFIER";
  TokenType["IDENTIFIER"] = "IDENTIFIER";
  TokenType["STRING"] = "STRING";
  TokenType["VARIABLE"] = "VARIABLE";
  TokenType["RESERVED_KEYWORD"] = "RESERVED_KEYWORD";
  TokenType["RESERVED_FUNCTION_NAME"] = "RESERVED_FUNCTION_NAME";
  TokenType["RESERVED_PHRASE"] = "RESERVED_PHRASE";
  TokenType["RESERVED_DEPENDENT_CLAUSE"] = "RESERVED_DEPENDENT_CLAUSE";
  TokenType["RESERVED_SET_OPERATION"] = "RESERVED_SET_OPERATION";
  TokenType["RESERVED_COMMAND"] = "RESERVED_COMMAND";
  TokenType["RESERVED_SELECT"] = "RESERVED_SELECT";
  TokenType["RESERVED_JOIN"] = "RESERVED_JOIN";
  TokenType["ARRAY_IDENTIFIER"] = "ARRAY_IDENTIFIER";
  TokenType["ARRAY_KEYWORD"] = "ARRAY_KEYWORD";
  TokenType["CASE"] = "CASE";
  TokenType["END"] = "END";
  TokenType["LIMIT"] = "LIMIT";
  TokenType["BETWEEN"] = "BETWEEN";
  TokenType["AND"] = "AND";
  TokenType["OR"] = "OR";
  TokenType["XOR"] = "XOR";
  TokenType["OPERATOR"] = "OPERATOR";
  TokenType["COMMA"] = "COMMA";
  TokenType["ASTERISK"] = "ASTERISK";
  TokenType["DOT"] = "DOT";
  TokenType["OPEN_PAREN"] = "OPEN_PAREN";
  TokenType["CLOSE_PAREN"] = "CLOSE_PAREN";
  TokenType["LINE_COMMENT"] = "LINE_COMMENT";
  TokenType["BLOCK_COMMENT"] = "BLOCK_COMMENT";
  TokenType["NUMBER"] = "NUMBER";
  TokenType["NAMED_PARAMETER"] = "NAMED_PARAMETER";
  TokenType["QUOTED_PARAMETER"] = "QUOTED_PARAMETER";
  TokenType["NUMBERED_PARAMETER"] = "NUMBERED_PARAMETER";
  TokenType["POSITIONAL_PARAMETER"] = "POSITIONAL_PARAMETER";
  TokenType["DELIMITER"] = "DELIMITER";
  TokenType["EOF"] = "EOF";
})(TokenType || (exports.TokenType = TokenType = {}));

/** Creates EOF token positioned at given location */
var createEofToken = function createEofToken(index) {
  return {
    type: TokenType.EOF,
    raw: '«EOF»',
    text: '«EOF»',
    start: index
  };
};
/**
 * For use as a "missing token"
 * e.g. in lookAhead and lookBehind to avoid dealing with null values
 */


exports.createEofToken = createEofToken;
var EOF_TOKEN = createEofToken(Infinity);
/** Checks if two tokens are equivalent */

exports.EOF_TOKEN = EOF_TOKEN;

var testToken = function testToken(compareToken) {
  return function (token) {
    return token.type === compareToken.type && token.text === compareToken.text;
  };
};
/** Util object that allows for easy checking of Reserved Keywords */


exports.testToken = testToken;
var isToken = {
  ARRAY: testToken({
    text: 'ARRAY',
    type: TokenType.RESERVED_KEYWORD
  }),
  BY: testToken({
    text: 'BY',
    type: TokenType.RESERVED_KEYWORD
  }),
  SET: testToken({
    text: 'SET',
    type: TokenType.RESERVED_COMMAND
  }),
  STRUCT: testToken({
    text: 'STRUCT',
    type: TokenType.RESERVED_KEYWORD
  }),
  WINDOW: testToken({
    text: 'WINDOW',
    type: TokenType.RESERVED_COMMAND
  })
};
/** Checks if token is any Reserved Keyword or Command */

exports.isToken = isToken;

var isReserved = function isReserved(type) {
  return type === TokenType.RESERVED_KEYWORD || type === TokenType.RESERVED_FUNCTION_NAME || type === TokenType.RESERVED_PHRASE || type === TokenType.RESERVED_DEPENDENT_CLAUSE || type === TokenType.RESERVED_COMMAND || type === TokenType.RESERVED_SELECT || type === TokenType.RESERVED_SET_OPERATION || type === TokenType.RESERVED_JOIN || type === TokenType.ARRAY_KEYWORD || type === TokenType.CASE || type === TokenType.END || type === TokenType.LIMIT || type === TokenType.BETWEEN || type === TokenType.AND || type === TokenType.OR || type === TokenType.XOR;
};

exports.isReserved = isReserved;

var isLogicalOperator = function isLogicalOperator(type) {
  return type === TokenType.AND || type === TokenType.OR || type === TokenType.XOR;
};

exports.isLogicalOperator = isLogicalOperator;
//# sourceMappingURL=token.js.map