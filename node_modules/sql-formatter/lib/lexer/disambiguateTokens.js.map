{"version":3,"file":"disambiguateTokens.js","names":["disambiguateTokens","tokens","map","dotKeywordToIdent","funcNameToKeyword","identToArrayIdent","keywordToArrayKeyword","token","i","isReserved","type","prevToken","prevNonCommentToken","text","TokenType","IDENTIFIER","raw","RESERVED_FUNCTION_NAME","nextToken","nextNonCommentToken","isOpenParen","RESERVED_KEYWORD","isOpenBracket","ARRAY_IDENTIFIER","ARRAY_KEYWORD","index","dir","isComment","t","OPEN_PAREN","BLOCK_COMMENT","LINE_COMMENT"],"sources":["../../src/lexer/disambiguateTokens.ts"],"sourcesContent":["import { isReserved, Token, TokenType } from 'src/lexer/token';\n\n/**\n * Ensures that no keyword token (RESERVED_*) is preceded by dot (.).\n *\n * Ensures that all RESERVED_FUNCTION_NAME tokens are followed by \"(\".\n * If they're not, converts the token to RESERVED_KEYWORD.\n *\n * When IDENTIFIER and RESERVED_KEYWORD token is followed by \"[\"\n * converts it to ARRAY_IDENTIFIER or ARRAY_KEYWORD accordingly.\n *\n * This is needed to avoid ambiguity in parser which expects function names\n * to always be followed by open-paren, and to distinguish between\n * array accessor `foo[1]` and array literal `[1, 2, 3]`.\n */\nexport function disambiguateTokens(tokens: Token[]): Token[] {\n  return tokens\n    .map(dotKeywordToIdent)\n    .map(funcNameToKeyword)\n    .map(identToArrayIdent)\n    .map(keywordToArrayKeyword);\n}\n\nconst dotKeywordToIdent = (token: Token, i: number, tokens: Token[]): Token => {\n  if (isReserved(token.type)) {\n    const prevToken = prevNonCommentToken(tokens, i);\n    if (prevToken && prevToken.text === '.') {\n      return { ...token, type: TokenType.IDENTIFIER, text: token.raw };\n    }\n  }\n  return token;\n};\n\nconst funcNameToKeyword = (token: Token, i: number, tokens: Token[]): Token => {\n  if (token.type === TokenType.RESERVED_FUNCTION_NAME) {\n    const nextToken = nextNonCommentToken(tokens, i);\n    if (!nextToken || !isOpenParen(nextToken)) {\n      return { ...token, type: TokenType.RESERVED_KEYWORD };\n    }\n  }\n  return token;\n};\n\nconst identToArrayIdent = (token: Token, i: number, tokens: Token[]): Token => {\n  if (token.type === TokenType.IDENTIFIER) {\n    const nextToken = nextNonCommentToken(tokens, i);\n    if (nextToken && isOpenBracket(nextToken)) {\n      return { ...token, type: TokenType.ARRAY_IDENTIFIER };\n    }\n  }\n  return token;\n};\n\nconst keywordToArrayKeyword = (token: Token, i: number, tokens: Token[]): Token => {\n  if (token.type === TokenType.RESERVED_KEYWORD) {\n    const nextToken = nextNonCommentToken(tokens, i);\n    if (nextToken && isOpenBracket(nextToken)) {\n      return { ...token, type: TokenType.ARRAY_KEYWORD };\n    }\n  }\n  return token;\n};\n\nconst prevNonCommentToken = (tokens: Token[], index: number): Token | undefined =>\n  nextNonCommentToken(tokens, index, -1);\n\nconst nextNonCommentToken = (\n  tokens: Token[],\n  index: number,\n  dir: -1 | 1 = 1\n): Token | undefined => {\n  let i = 1;\n  while (tokens[index + i * dir] && isComment(tokens[index + i * dir])) {\n    i++;\n  }\n  return tokens[index + i * dir];\n};\n\nconst isOpenParen = (t: Token): boolean => t.type === TokenType.OPEN_PAREN && t.text === '(';\n\nconst isOpenBracket = (t: Token): boolean => t.type === TokenType.OPEN_PAREN && t.text === '[';\n\nconst isComment = (t: Token): boolean =>\n  t.type === TokenType.BLOCK_COMMENT || t.type === TokenType.LINE_COMMENT;\n"],"mappings":"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"}