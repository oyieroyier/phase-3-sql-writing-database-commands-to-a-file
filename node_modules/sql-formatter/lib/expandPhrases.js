"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.expandSinglePhrase = exports.expandPhrases = void 0;

function _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/**
 * Performs expandSinglePhrase() on array
 */
var expandPhrases = function expandPhrases(phrases) {
  return phrases.flatMap(expandSinglePhrase);
};
/**
 * Expands a syntax description like
 *
 *     "CREATE [OR REPLACE] [TEMP|TEMPORARY] TABLE"
 *
 * into an array of all possible combinations like:
 *
 *     [ "CREATE TABLE",
 *       "CREATE TEMP TABLE",
 *       "CREATE TEMPORARY TABLE",
 *       "CREATE OR REPLACE TABLE",
 *       "CREATE OR REPLACE TEMP TABLE",
 *       "CREATE OR REPLACE TEMPORARY TABLE" ]
 */


exports.expandPhrases = expandPhrases;

var expandSinglePhrase = function expandSinglePhrase(phrase) {
  return buildCombinations(parsePhrase(phrase)).map(function (text) {
    return text.trim();
  });
}; // This data type holds variants of a single part in whole phrase.
// Corresponding to syntax as follows:
//
//   "TABLE"            --> ["TABLE"]
//   "[TABLE]"          --> ["", "TABLE"]
//   "[TEMP|TEMPORARY]" --> ["", "TEMP", "TEMPORARY"]
//   "{TEMP|TEMPORARY}" --> ["TEMP", "TEMPORARY"]
//


exports.expandSinglePhrase = expandSinglePhrase;
var REQUIRED_PART = new RegExp("[^[\\]{}]+", "y");
var REQUIRED_BLOCK = new RegExp("\\{.*?\\}", "y");
var OPTIONAL_BLOCK = new RegExp("\\[.*?\\]", "y");

var parsePhrase = function parsePhrase(text) {
  var index = 0;
  var result = [];

  while (index < text.length) {
    // Match everything else outside of "[...]" or "{...}" blocks
    REQUIRED_PART.lastIndex = index;
    var requiredMatch = REQUIRED_PART.exec(text);

    if (requiredMatch) {
      result.push([requiredMatch[0].trim()]);
      index += requiredMatch[0].length;
    } // Match "[...]" block


    OPTIONAL_BLOCK.lastIndex = index;
    var optionalBlockMatch = OPTIONAL_BLOCK.exec(text);

    if (optionalBlockMatch) {
      var choices = optionalBlockMatch[0].slice(1, -1).split('|').map(function (s) {
        return s.trim();
      });
      result.push([''].concat(_toConsumableArray(choices)));
      index += optionalBlockMatch[0].length;
    } // Match "{...}" block


    REQUIRED_BLOCK.lastIndex = index;
    var requiredBlockMatch = REQUIRED_BLOCK.exec(text);

    if (requiredBlockMatch) {
      var _choices = requiredBlockMatch[0].slice(1, -1).split('|').map(function (s) {
        return s.trim();
      });

      result.push(_choices);
      index += requiredBlockMatch[0].length;
    }

    if (!requiredMatch && !optionalBlockMatch && !requiredBlockMatch) {
      throw new Error("Unbalanced parenthesis in: ".concat(text));
    }
  }

  return result;
};

var buildCombinations = function buildCombinations(_ref) {
  var _ref2 = _toArray(_ref),
      first = _ref2[0],
      rest = _ref2.slice(1);

  if (first === undefined) {
    return [''];
  }

  return buildCombinations(rest).flatMap(function (tail) {
    return first.map(function (head) {
      return head.trim() + ' ' + tail.trim();
    });
  });
};
//# sourceMappingURL=expandPhrases.js.map