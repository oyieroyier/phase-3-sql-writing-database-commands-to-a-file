"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _expandPhrases = require("../../expandPhrases");

var _Formatter2 = _interopRequireDefault(require("../../formatter/Formatter"));

var _Tokenizer = _interopRequireDefault(require("../../lexer/Tokenizer"));

var _token = require("../../lexer/token");

var _spark = require("./spark.keywords");

var _spark2 = require("./spark.functions");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

// http://spark.apache.org/docs/latest/sql-ref-syntax.html
var reservedSelect = (0, _expandPhrases.expandPhrases)(['SELECT [ALL | DISTINCT]']);
var reservedCommands = (0, _expandPhrases.expandPhrases)([// queries
'WITH', 'FROM', 'WHERE', 'GROUP BY', 'HAVING', 'WINDOW', 'PARTITION BY', 'ORDER BY', 'SORT BY', 'CLUSTER BY', 'DISTRIBUTE BY', 'LIMIT', // Data manipulation
// - insert:
'INSERT [INTO | OVERWRITE] [TABLE]', 'VALUES', // - truncate:
'TRUNCATE TABLE', // - insert overwrite directory:
//   https://spark.apache.org/docs/latest/sql-ref-syntax-dml-insert-overwrite-directory.html
'INSERT OVERWRITE [LOCAL] DIRECTORY', // - load:
//   https://spark.apache.org/docs/latest/sql-ref-syntax-dml-load.html
'LOAD DATA [LOCAL] INPATH', '[OVERWRITE] INTO TABLE', // Data definition
'CREATE [OR REPLACE] [GLOBAL TEMPORARY | TEMPORARY] VIEW [IF NOT EXISTS]', 'CREATE [EXTERNAL] TABLE [IF NOT EXISTS]', 'DROP TABLE [IF EXISTS]', // - alter table:
'ALTER TABLE', 'ADD COLUMNS', 'DROP {COLUMN | COLUMNS}', 'RENAME TO', 'RENAME COLUMN', 'ALTER COLUMN', 'ALTER DATABASE', 'ALTER VIEW', 'CREATE DATABASE', 'CREATE FUNCTION', 'DROP DATABASE', 'DROP FUNCTION', 'DROP VIEW', 'REPAIR TABLE', 'USE DATABASE', // Data Retrieval
'TABLESAMPLE', 'PIVOT', 'TRANSFORM', 'EXPLAIN', // Auxiliary
'ADD FILE', 'ADD JAR', 'ANALYZE TABLE', 'CACHE TABLE', 'CLEAR CACHE', 'DESCRIBE DATABASE', 'DESCRIBE FUNCTION', 'DESCRIBE QUERY', 'DESCRIBE TABLE', 'LIST FILE', 'LIST JAR', 'REFRESH', 'REFRESH TABLE', 'REFRESH FUNCTION', 'RESET', 'SHOW COLUMNS', 'SHOW CREATE TABLE', 'SHOW DATABASES', 'SHOW FUNCTIONS', 'SHOW PARTITIONS', 'SHOW TABLE EXTENDED', 'SHOW TABLES', 'SHOW TBLPROPERTIES', 'SHOW VIEWS', 'UNCACHE TABLE', // other
'LATERAL VIEW']);
var reservedSetOperations = (0, _expandPhrases.expandPhrases)(['UNION [ALL | DISTINCT]', 'EXCEPT [ALL | DISTINCT]', 'INTERSECT [ALL | DISTINCT]']);
var reservedJoins = (0, _expandPhrases.expandPhrases)(['JOIN', '{LEFT | RIGHT | FULL} [OUTER] JOIN', '{INNER | CROSS} JOIN', 'NATURAL [INNER] JOIN', 'NATURAL {LEFT | RIGHT | FULL} [OUTER] JOIN', // non-standard-joins
'[LEFT] {ANTI | SEMI} JOIN', 'NATURAL [LEFT] {ANTI | SEMI} JOIN']);
var reservedPhrases = (0, _expandPhrases.expandPhrases)(['ON DELETE', 'ON UPDATE', 'CURRENT ROW', '{ROWS | RANGE} BETWEEN']); // http://spark.apache.org/docs/latest/sql-programming-guide.html

var SparkFormatter = /*#__PURE__*/function (_Formatter) {
  _inherits(SparkFormatter, _Formatter);

  var _super = _createSuper(SparkFormatter);

  function SparkFormatter() {
    _classCallCheck(this, SparkFormatter);

    return _super.apply(this, arguments);
  }

  _createClass(SparkFormatter, [{
    key: "tokenizer",
    value: function tokenizer() {
      return new _Tokenizer["default"]({
        reservedCommands: reservedCommands,
        reservedSelect: reservedSelect,
        reservedSetOperations: reservedSetOperations,
        reservedJoins: reservedJoins,
        reservedDependentClauses: ['WHEN', 'ELSE'],
        reservedPhrases: reservedPhrases,
        supportsXor: true,
        reservedKeywords: _spark.keywords,
        reservedFunctionNames: _spark2.functions,
        extraParens: ['[]'],
        stringTypes: ["''-bs", '""-bs', {
          quote: "''-raw",
          prefixes: ['R', 'X'],
          requirePrefix: true
        }, {
          quote: '""-raw',
          prefixes: ['R', 'X'],
          requirePrefix: true
        }],
        identTypes: ['``'],
        variableTypes: [{
          quote: '{}',
          prefixes: ['$'],
          requirePrefix: true
        }],
        operators: ['%', '~', '^', '|', '&', '<=>', '==', '!', '||', '->'],
        postProcess: postProcess
      });
    }
  }]);

  return SparkFormatter;
}(_Formatter2["default"]);

exports["default"] = SparkFormatter;

function postProcess(tokens) {
  return tokens.map(function (token, i) {
    var prevToken = tokens[i - 1] || _token.EOF_TOKEN;
    var nextToken = tokens[i + 1] || _token.EOF_TOKEN; // [WINDOW](...)

    if (_token.isToken.WINDOW(token) && nextToken.type === _token.TokenType.OPEN_PAREN) {
      // This is a function call, treat it as a reserved function name
      return _objectSpread(_objectSpread({}, token), {}, {
        type: _token.TokenType.RESERVED_FUNCTION_NAME
      });
    } // TODO: deprecate this once ITEMS is merged with COLLECTION


    if (token.text === 'ITEMS' && token.type === _token.TokenType.RESERVED_KEYWORD) {
      if (!(prevToken.text === 'COLLECTION' && nextToken.text === 'TERMINATED')) {
        // this is a word and not COLLECTION ITEMS
        return _objectSpread(_objectSpread({}, token), {}, {
          type: _token.TokenType.IDENTIFIER,
          text: token.raw
        });
      }
    }

    return token;
  });
}

module.exports = exports.default;
//# sourceMappingURL=spark.formatter.js.map