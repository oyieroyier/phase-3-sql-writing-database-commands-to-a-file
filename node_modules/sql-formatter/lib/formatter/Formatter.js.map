{"version":3,"file":"Formatter.js","names":["Formatter","cfg","params","Params","Error","cls","constructor","cachedTokenizer","tokenizer","query","ast","parse","formattedQuery","formatAst","finalQuery","postFormat","trimEnd","createParser","paramTypes","statements","map","stat","formatStatement","join","repeat","linesBetweenQueries","statement","layout","ExpressionFormatter","Layout","Indentation","indentString","format","children","hasSemicolon","newlineBeforeSemicolon","add","WS","NEWLINE","NO_NEWLINE","toString","tabulateAlias","formatAliasPositions","commaPosition","formatCommaPositions"],"sources":["../../src/formatter/Formatter.ts"],"sourcesContent":["import { FormatOptions } from 'src/FormatOptions';\nimport { indentString } from 'src/formatter/config';\nimport Params from 'src/formatter/Params';\nimport Tokenizer from 'src/lexer/Tokenizer';\n\nimport { createParser } from 'src/parser/createParser';\nimport { StatementNode } from 'src/parser/ast';\n\nimport formatCommaPositions from './formatCommaPositions';\nimport formatAliasPositions from './formatAliasPositions';\nimport ExpressionFormatter from './ExpressionFormatter';\nimport Layout, { WS } from './Layout';\nimport Indentation from './Indentation';\n\n/** Main formatter class that produces a final output string from list of tokens */\nexport default class Formatter {\n  private cfg: FormatOptions;\n  private params: Params;\n\n  constructor(cfg: FormatOptions) {\n    this.cfg = cfg;\n    this.params = new Params(this.cfg.params);\n  }\n\n  /**\n   * SQL Tokenizer for this formatter, provided by subclasses.\n   */\n  protected tokenizer(): Tokenizer {\n    throw new Error('tokenizer() not implemented by subclass');\n  }\n\n  // Cache the tokenizer for each class (each SQL dialect)\n  // So we wouldn't need to recreate the tokenizer, which is kinda expensive,\n  // for each call to format() function.\n  private cachedTokenizer(): Tokenizer {\n    const cls: Function & { cachedTokenizer?: Tokenizer } = this.constructor;\n    if (!cls.cachedTokenizer) {\n      cls.cachedTokenizer = this.tokenizer();\n    }\n    return cls.cachedTokenizer;\n  }\n\n  /**\n   * Formats an SQL query.\n   * @param {string} query - The SQL query string to be formatted\n   * @return {string} The formatter query\n   */\n  public format(query: string): string {\n    const ast = this.parse(query);\n    const formattedQuery = this.formatAst(ast);\n    const finalQuery = this.postFormat(formattedQuery);\n\n    return finalQuery.trimEnd();\n  }\n\n  private parse(query: string): StatementNode[] {\n    return createParser(this.cachedTokenizer()).parse(query, this.cfg.paramTypes || {});\n  }\n\n  private formatAst(statements: StatementNode[]): string {\n    return statements\n      .map(stat => this.formatStatement(stat))\n      .join('\\n'.repeat(this.cfg.linesBetweenQueries + 1));\n  }\n\n  private formatStatement(statement: StatementNode): string {\n    const layout = new ExpressionFormatter({\n      cfg: this.cfg,\n      params: this.params,\n      layout: new Layout(new Indentation(indentString(this.cfg))),\n    }).format(statement.children);\n\n    if (!statement.hasSemicolon) {\n      // do nothing\n    } else if (this.cfg.newlineBeforeSemicolon) {\n      layout.add(WS.NEWLINE, ';');\n    } else {\n      layout.add(WS.NO_NEWLINE, ';');\n    }\n    return layout.toString();\n  }\n\n  private postFormat(query: string): string {\n    if (this.cfg.tabulateAlias) {\n      query = formatAliasPositions(query);\n    }\n    if (this.cfg.commaPosition === 'before' || this.cfg.commaPosition === 'tabular') {\n      query = formatCommaPositions(query, this.cfg.commaPosition, indentString(this.cfg));\n    }\n\n    return query;\n  }\n}\n"],"mappings":";;;;;;;;;AACA;;AACA;;AAGA;;AAGA;;AACA;;AACA;;AACA;;AACA;;;;;;;;;;;;;;;;AAEA;IACqBA,S;EAInB,mBAAYC,GAAZ,EAAgC;IAAA;;IAAA;;IAAA;;IAC9B,KAAKA,GAAL,GAAWA,GAAX;IACA,KAAKC,MAAL,GAAc,IAAIC,kBAAJ,CAAW,KAAKF,GAAL,CAASC,MAApB,CAAd;EACD;EAED;AACF;AACA;;;;;WACE,qBAAiC;MAC/B,MAAM,IAAIE,KAAJ,CAAU,yCAAV,CAAN;IACD,C,CAED;IACA;IACA;;;;WACA,2BAAqC;MACnC,IAAMC,GAA+C,GAAG,KAAKC,WAA7D;;MACA,IAAI,CAACD,GAAG,CAACE,eAAT,EAA0B;QACxBF,GAAG,CAACE,eAAJ,GAAsB,KAAKC,SAAL,EAAtB;MACD;;MACD,OAAOH,GAAG,CAACE,eAAX;IACD;IAED;AACF;AACA;AACA;AACA;;;;WACE,gBAAcE,KAAd,EAAqC;MACnC,IAAMC,GAAG,GAAG,KAAKC,KAAL,CAAWF,KAAX,CAAZ;MACA,IAAMG,cAAc,GAAG,KAAKC,SAAL,CAAeH,GAAf,CAAvB;MACA,IAAMI,UAAU,GAAG,KAAKC,UAAL,CAAgBH,cAAhB,CAAnB;MAEA,OAAOE,UAAU,CAACE,OAAX,EAAP;IACD;;;WAED,eAAcP,KAAd,EAA8C;MAC5C,OAAO,IAAAQ,0BAAA,EAAa,KAAKV,eAAL,EAAb,EAAqCI,KAArC,CAA2CF,KAA3C,EAAkD,KAAKR,GAAL,CAASiB,UAAT,IAAuB,EAAzE,CAAP;IACD;;;WAED,mBAAkBC,UAAlB,EAAuD;MAAA;;MACrD,OAAOA,UAAU,CACdC,GADI,CACA,UAAAC,IAAI;QAAA,OAAI,KAAI,CAACC,eAAL,CAAqBD,IAArB,CAAJ;MAAA,CADJ,EAEJE,IAFI,CAEC,KAAKC,MAAL,CAAY,KAAKvB,GAAL,CAASwB,mBAAT,GAA+B,CAA3C,CAFD,CAAP;IAGD;;;WAED,yBAAwBC,SAAxB,EAA0D;MACxD,IAAMC,MAAM,GAAG,IAAIC,+BAAJ,CAAwB;QACrC3B,GAAG,EAAE,KAAKA,GAD2B;QAErCC,MAAM,EAAE,KAAKA,MAFwB;QAGrCyB,MAAM,EAAE,IAAIE,kBAAJ,CAAW,IAAIC,uBAAJ,CAAgB,IAAAC,oBAAA,EAAa,KAAK9B,GAAlB,CAAhB,CAAX;MAH6B,CAAxB,EAIZ+B,MAJY,CAILN,SAAS,CAACO,QAJL,CAAf;;MAMA,IAAI,CAACP,SAAS,CAACQ,YAAf,EAA6B,CAC3B;MACD,CAFD,MAEO,IAAI,KAAKjC,GAAL,CAASkC,sBAAb,EAAqC;QAC1CR,MAAM,CAACS,GAAP,CAAWC,UAAA,CAAGC,OAAd,EAAuB,GAAvB;MACD,CAFM,MAEA;QACLX,MAAM,CAACS,GAAP,CAAWC,UAAA,CAAGE,UAAd,EAA0B,GAA1B;MACD;;MACD,OAAOZ,MAAM,CAACa,QAAP,EAAP;IACD;;;WAED,oBAAmB/B,KAAnB,EAA0C;MACxC,IAAI,KAAKR,GAAL,CAASwC,aAAb,EAA4B;QAC1BhC,KAAK,GAAG,IAAAiC,gCAAA,EAAqBjC,KAArB,CAAR;MACD;;MACD,IAAI,KAAKR,GAAL,CAAS0C,aAAT,KAA2B,QAA3B,IAAuC,KAAK1C,GAAL,CAAS0C,aAAT,KAA2B,SAAtE,EAAiF;QAC/ElC,KAAK,GAAG,IAAAmC,gCAAA,EAAqBnC,KAArB,EAA4B,KAAKR,GAAL,CAAS0C,aAArC,EAAoD,IAAAZ,oBAAA,EAAa,KAAK9B,GAAlB,CAApD,CAAR;MACD;;MAED,OAAOQ,KAAP;IACD"}