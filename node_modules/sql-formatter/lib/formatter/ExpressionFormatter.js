"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _utils = require("../utils");

var _config = require("./config");

var _token = require("../lexer/token");

var _ast = require("../parser/ast");

var _Layout = require("./Layout");

var _tabularStyle = _interopRequireWildcard(require("./tabularStyle"));

var _InlineLayout = _interopRequireWildcard(require("./InlineLayout"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/** Formats a generic SQL expression */
var ExpressionFormatter = /*#__PURE__*/function () {
  function ExpressionFormatter(_ref) {
    var cfg = _ref.cfg,
        params = _ref.params,
        layout = _ref.layout,
        _ref$inline = _ref.inline,
        inline = _ref$inline === void 0 ? false : _ref$inline;

    _classCallCheck(this, ExpressionFormatter);

    _defineProperty(this, "cfg", void 0);

    _defineProperty(this, "params", void 0);

    _defineProperty(this, "layout", void 0);

    _defineProperty(this, "inline", false);

    _defineProperty(this, "nodes", []);

    _defineProperty(this, "index", -1);

    this.cfg = cfg;
    this.inline = inline;
    this.params = params;
    this.layout = layout;
  }

  _createClass(ExpressionFormatter, [{
    key: "format",
    value: function format(nodes) {
      this.nodes = nodes;

      for (this.index = 0; this.index < this.nodes.length; this.index++) {
        this.formatNode(this.nodes[this.index]);
      }

      return this.layout;
    }
  }, {
    key: "formatNode",
    value: function formatNode(node) {
      this.formatComments(node.leadingComments);
      this.formatNodeWithoutComments(node);
      this.formatComments(node.trailingComments);
    }
  }, {
    key: "formatNodeWithoutComments",
    value: function formatNodeWithoutComments(node) {
      switch (node.type) {
        case _ast.NodeType.function_call:
          return this.formatFunctionCall(node);

        case _ast.NodeType.array_subscript:
          return this.formatArraySubscript(node);

        case _ast.NodeType.property_access:
          return this.formatPropertyAccess(node);

        case _ast.NodeType.parenthesis:
          return this.formatParenthesis(node);

        case _ast.NodeType.between_predicate:
          return this.formatBetweenPredicate(node);

        case _ast.NodeType.clause:
          return this.formatClause(node);

        case _ast.NodeType.set_operation:
          return this.formatSetOperation(node);

        case _ast.NodeType.limit_clause:
          return this.formatLimitClause(node);

        case _ast.NodeType.all_columns_asterisk:
          return this.formatAllColumnsAsterisk(node);

        case _ast.NodeType.literal:
          return this.formatLiteral(node);

        case _ast.NodeType.identifier:
          return this.formatIdentifier(node);

        case _ast.NodeType.parameter:
          return this.formatParameter(node);

        case _ast.NodeType.operator:
          return this.formatOperator(node);

        case _ast.NodeType.comma:
          return this.formatComma(node);

        case _ast.NodeType.line_comment:
          return this.formatLineComment(node);

        case _ast.NodeType.block_comment:
          return this.formatBlockComment(node);

        case _ast.NodeType.keyword:
          return this.formatKeywordNode(node);
      }
    }
  }, {
    key: "formatFunctionCall",
    value: function formatFunctionCall(node) {
      var _this = this;

      this.withComments(node.name, function () {
        _this.layout.add(_this.showKw(node.name));
      });
      this.formatNode(node.parenthesis);
    }
  }, {
    key: "formatArraySubscript",
    value: function formatArraySubscript(node) {
      var _this2 = this;

      this.withComments(node.array, function () {
        _this2.layout.add(node.array.type === _ast.NodeType.keyword ? _this2.showKw(node.array) : node.array.text);
      });
      this.formatNode(node.parenthesis);
    }
  }, {
    key: "formatPropertyAccess",
    value: function formatPropertyAccess(node) {
      this.formatNode(node.object);
      this.layout.add(_Layout.WS.NO_SPACE, '.');
      this.formatNode(node.property);
    }
  }, {
    key: "formatParenthesis",
    value: function formatParenthesis(node) {
      var inlineLayout = this.formatInlineExpression(node.children);

      if (inlineLayout) {
        var _this$layout;

        this.layout.add(node.openParen);

        (_this$layout = this.layout).add.apply(_this$layout, _toConsumableArray(inlineLayout.getLayoutItems()));

        this.layout.add(_Layout.WS.NO_SPACE, node.closeParen, _Layout.WS.SPACE);
      } else {
        this.layout.add(node.openParen, _Layout.WS.NEWLINE);

        if ((0, _config.isTabularStyle)(this.cfg)) {
          this.layout.add(_Layout.WS.INDENT);
          this.layout = this.formatSubExpression(node.children);
        } else {
          this.layout.indentation.increaseBlockLevel();
          this.layout.add(_Layout.WS.INDENT);
          this.layout = this.formatSubExpression(node.children);
          this.layout.indentation.decreaseBlockLevel();
        }

        this.layout.add(_Layout.WS.NEWLINE, _Layout.WS.INDENT, node.closeParen, _Layout.WS.SPACE);
      }
    }
  }, {
    key: "formatBetweenPredicate",
    value: function formatBetweenPredicate(node) {
      this.layout.add(this.showKw(node.between), _Layout.WS.SPACE);
      this.layout = this.formatSubExpression(node.expr1);
      this.layout.add(_Layout.WS.NO_SPACE, _Layout.WS.SPACE, this.showNonTabularKw(node.and), _Layout.WS.SPACE);
      this.layout = this.formatSubExpression(node.expr2);
      this.layout.add(_Layout.WS.SPACE);
    }
  }, {
    key: "formatClause",
    value: function formatClause(node) {
      if ((0, _config.isTabularStyle)(this.cfg)) {
        this.layout.add(_Layout.WS.NEWLINE, _Layout.WS.INDENT, this.showKw(node.name), _Layout.WS.SPACE);
      } else {
        this.layout.add(_Layout.WS.NEWLINE, _Layout.WS.INDENT, this.showKw(node.name), _Layout.WS.NEWLINE);
      }

      this.layout.indentation.increaseTopLevel();

      if (!(0, _config.isTabularStyle)(this.cfg)) {
        this.layout.add(_Layout.WS.INDENT);
      }

      this.layout = this.formatSubExpression(node.children);
      this.layout.indentation.decreaseTopLevel();
    }
  }, {
    key: "formatSetOperation",
    value: function formatSetOperation(node) {
      this.layout.add(_Layout.WS.NEWLINE, _Layout.WS.INDENT, this.showKw(node.name), _Layout.WS.NEWLINE);
      this.layout.add(_Layout.WS.INDENT);
      this.layout = this.formatSubExpression(node.children);
    }
  }, {
    key: "formatLimitClause",
    value: function formatLimitClause(node) {
      var _this3 = this;

      this.withComments(node.name, function () {
        _this3.layout.add(_Layout.WS.NEWLINE, _Layout.WS.INDENT, _this3.showKw(node.name));
      });
      this.layout.indentation.increaseTopLevel();

      if ((0, _config.isTabularStyle)(this.cfg)) {
        this.layout.add(_Layout.WS.SPACE);
      } else {
        this.layout.add(_Layout.WS.NEWLINE, _Layout.WS.INDENT);
      }

      if (node.offset) {
        this.layout = this.formatSubExpression(node.offset);
        this.layout.add(_Layout.WS.NO_SPACE, ',', _Layout.WS.SPACE);
        this.layout = this.formatSubExpression(node.count);
      } else {
        this.layout = this.formatSubExpression(node.count);
      }

      this.layout.indentation.decreaseTopLevel();
    }
  }, {
    key: "formatAllColumnsAsterisk",
    value: function formatAllColumnsAsterisk(_node) {
      this.layout.add('*', _Layout.WS.SPACE);
    }
  }, {
    key: "formatLiteral",
    value: function formatLiteral(node) {
      this.layout.add(node.text, _Layout.WS.SPACE);
    }
  }, {
    key: "formatIdentifier",
    value: function formatIdentifier(node) {
      this.layout.add(node.text, _Layout.WS.SPACE);
    }
  }, {
    key: "formatParameter",
    value: function formatParameter(node) {
      this.layout.add(this.params.get(node), _Layout.WS.SPACE);
    }
  }, {
    key: "formatOperator",
    value: function formatOperator(_ref2) {
      var text = _ref2.text;

      // special operator
      if (text === ':') {
        this.layout.add(_Layout.WS.NO_SPACE, text, _Layout.WS.SPACE);
        return;
      } else if (text === '::') {
        this.layout.add(_Layout.WS.NO_SPACE, text);
        return;
      } // special case for PLSQL @ dblink syntax
      else if (text === '@' && this.cfg.language === 'plsql') {
        this.layout.add(_Layout.WS.NO_SPACE, text);
        return;
      } // other operators


      if (this.cfg.denseOperators) {
        this.layout.add(_Layout.WS.NO_SPACE, text);
      } else {
        this.layout.add(text, _Layout.WS.SPACE);
      }
    }
  }, {
    key: "formatComma",
    value: function formatComma(_node) {
      if (!this.inline) {
        this.layout.add(_Layout.WS.NO_SPACE, ',', _Layout.WS.NEWLINE, _Layout.WS.INDENT);
      } else {
        this.layout.add(_Layout.WS.NO_SPACE, ',', _Layout.WS.SPACE);
      }
    }
  }, {
    key: "withComments",
    value: function withComments(node, fn) {
      this.formatComments(node.leadingComments);
      fn();
      this.formatComments(node.trailingComments);
    }
  }, {
    key: "formatComments",
    value: function formatComments(comments) {
      var _this4 = this;

      if (!comments) {
        return;
      }

      comments.forEach(function (com) {
        if (com.type === _ast.NodeType.line_comment) {
          _this4.formatLineComment(com);
        } else {
          _this4.formatBlockComment(com);
        }
      });
    }
  }, {
    key: "formatLineComment",
    value: function formatLineComment(node) {
      if (/\n/.test(node.precedingWhitespace || '')) {
        this.layout.add(_Layout.WS.NEWLINE, _Layout.WS.INDENT, node.text, _Layout.WS.MANDATORY_NEWLINE, _Layout.WS.INDENT);
      } else {
        this.layout.add(_Layout.WS.NO_NEWLINE, _Layout.WS.SPACE, node.text, _Layout.WS.MANDATORY_NEWLINE, _Layout.WS.INDENT);
      }
    }
  }, {
    key: "formatBlockComment",
    value: function formatBlockComment(node) {
      var _this5 = this;

      this.splitBlockComment(node.text).forEach(function (line) {
        _this5.layout.add(_Layout.WS.NEWLINE, _Layout.WS.INDENT, line);
      });
      this.layout.add(_Layout.WS.NEWLINE, _Layout.WS.INDENT);
    } // Breaks up block comment to multiple lines.
    // For example this comment (dots representing leading whitespace):
    //
    //   ..../**
    //   .....* Some description here
    //   .....* and here too
    //   .....*/
    //
    // gets broken to this array (note the leading single spaces):
    //
    //   [ '/**',
    //     '.* Some description here',
    //     '.* and here too',
    //     '.*/' ]
    //

  }, {
    key: "splitBlockComment",
    value: function splitBlockComment(comment) {
      return comment.split(/\n/).map(function (line) {
        if (/^\s*\*/.test(line)) {
          return ' ' + line.replace(/^\s*/, '');
        } else {
          return line.replace(/^\s*/, '');
        }
      });
    }
  }, {
    key: "formatSubExpression",
    value: function formatSubExpression(nodes) {
      return new ExpressionFormatter({
        cfg: this.cfg,
        params: this.params,
        layout: this.layout,
        inline: this.inline
      }).format(nodes);
    }
  }, {
    key: "formatInlineExpression",
    value: function formatInlineExpression(nodes) {
      var oldParamIndex = this.params.getPositionalParameterIndex();

      try {
        return new ExpressionFormatter({
          cfg: this.cfg,
          params: this.params,
          layout: new _InlineLayout["default"](this.cfg.expressionWidth),
          inline: true
        }).format(nodes);
      } catch (e) {
        if (e instanceof _InlineLayout.InlineLayoutError) {
          // While formatting, some of the positional parameters might have
          // been consumed, which increased the current parameter index.
          // We reset the index to an earlier state, so we can run the
          // formatting again and re-consume these parameters in non-inline mode.
          this.params.setPositionalParameterIndex(oldParamIndex);
          return undefined;
        } else {
          // forward all unexpected errors
          throw e;
        }
      }
    }
  }, {
    key: "formatKeywordNode",
    value: function formatKeywordNode(node) {
      switch (node.tokenType) {
        case _token.TokenType.RESERVED_JOIN:
          return this.formatJoin(node);

        case _token.TokenType.RESERVED_DEPENDENT_CLAUSE:
          return this.formatDependentClause(node);

        case _token.TokenType.AND:
        case _token.TokenType.OR:
        case _token.TokenType.XOR:
          return this.formatLogicalOperator(node);

        case _token.TokenType.RESERVED_KEYWORD:
        case _token.TokenType.RESERVED_FUNCTION_NAME:
        case _token.TokenType.RESERVED_PHRASE:
          return this.formatKeyword(node);

        case _token.TokenType.CASE:
          return this.formatCaseStart(node);

        case _token.TokenType.END:
          return this.formatCaseEnd(node);

        default:
          throw new Error("Unexpected token type: ".concat(node.tokenType));
      }
    }
  }, {
    key: "formatJoin",
    value: function formatJoin(node) {
      if ((0, _config.isTabularStyle)(this.cfg)) {
        // in tabular style JOINs are at the same level as clauses
        this.layout.indentation.decreaseTopLevel();
        this.layout.add(_Layout.WS.NEWLINE, _Layout.WS.INDENT, this.showKw(node), _Layout.WS.SPACE);
        this.layout.indentation.increaseTopLevel();
      } else {
        this.layout.add(_Layout.WS.NEWLINE, _Layout.WS.INDENT, this.showKw(node), _Layout.WS.SPACE);
      }
    }
  }, {
    key: "formatKeyword",
    value: function formatKeyword(node) {
      this.layout.add(this.showKw(node), _Layout.WS.SPACE);
    }
  }, {
    key: "formatDependentClause",
    value: function formatDependentClause(node) {
      this.layout.add(_Layout.WS.NEWLINE, _Layout.WS.INDENT, this.showKw(node), _Layout.WS.SPACE);
    }
  }, {
    key: "formatLogicalOperator",
    value: function formatLogicalOperator(node) {
      if (this.cfg.logicalOperatorNewline === 'before') {
        if ((0, _config.isTabularStyle)(this.cfg)) {
          // In tabular style AND/OR is placed on the same level as clauses
          this.layout.indentation.decreaseTopLevel();
          this.layout.add(_Layout.WS.NEWLINE, _Layout.WS.INDENT, this.showKw(node), _Layout.WS.SPACE);
          this.layout.indentation.increaseTopLevel();
        } else {
          this.layout.add(_Layout.WS.NEWLINE, _Layout.WS.INDENT, this.showKw(node), _Layout.WS.SPACE);
        }
      } else {
        this.layout.add(this.showKw(node), _Layout.WS.NEWLINE, _Layout.WS.INDENT);
      }
    }
  }, {
    key: "formatCaseStart",
    value: function formatCaseStart(node) {
      this.layout.indentation.increaseBlockLevel();
      this.layout.add(this.showKw(node), _Layout.WS.NEWLINE, _Layout.WS.INDENT);
    }
  }, {
    key: "formatCaseEnd",
    value: function formatCaseEnd(node) {
      this.formatMultilineBlockEnd(node);
    }
  }, {
    key: "formatMultilineBlockEnd",
    value: function formatMultilineBlockEnd(node) {
      this.layout.indentation.decreaseBlockLevel();
      this.layout.add(_Layout.WS.NEWLINE, _Layout.WS.INDENT, this.showKw(node), _Layout.WS.SPACE);
    }
  }, {
    key: "showKw",
    value: function showKw(node) {
      if ((0, _tabularStyle.isTabularToken)(node.tokenType)) {
        return (0, _tabularStyle["default"])(this.showNonTabularKw(node), this.cfg.indentStyle);
      } else {
        return this.showNonTabularKw(node);
      }
    } // Like showKw(), but skips tabular formatting

  }, {
    key: "showNonTabularKw",
    value: function showNonTabularKw(node) {
      switch (this.cfg.keywordCase) {
        case 'preserve':
          return (0, _utils.equalizeWhitespace)(node.raw);

        case 'upper':
          return node.text;

        case 'lower':
          return node.text.toLowerCase();
      }
    }
  }]);

  return ExpressionFormatter;
}();

exports["default"] = ExpressionFormatter;
module.exports = exports.default;
//# sourceMappingURL=ExpressionFormatter.js.map